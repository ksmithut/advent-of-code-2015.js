#!/usr/bin/env node
'use strict'

const path = require('path')
const fs = require('fs')
const program = require('commander')
const Promise = require('bluebird')
const chalk = require('chalk')

Promise.promisifyAll(fs)

const relative = path.join.bind(path, __dirname)
const RIGHT = chalk.green('✓')
const WRONG = chalk.red('✗')
const NOT_CHECKED = chalk.cyan('-')

program
  .parse(process.argv)

Promise.resolve(program.args)
  .mapSeries((day) => `day${padLeft(day, 2, '0')}`)
  .mapSeries((day) => Promise.props({
    input: fs.readFileAsync(relative(day, 'input.txt'), 'utf8'),
    module: require(`./${day}`)
  }))
  .mapSeries((day) => {
    console.log()
    console.log('Part 1:\n-------')
    runPart(day.module.part1, day.input)
    console.log('Part 2:\n-------')
    runPart(day.module.part2, day.input)
  })

function padLeft(string, length, char) {
  const diff = length - string.length
  if (diff <= 0) return string
  return new Array(diff).fill(char).join('') + string
}

function runPart(part, mainInput) {
  const method = part.fn
  const answer = part.answer
  const examples = part.examples || []
  if (!method) { return console.log('Not Implemented') }

  examples.forEach((example) => {
    let input = example.input
    const value = example.value
    input = Array.isArray(input) ? input : [ input ]

    const output = method.apply(null, input)

    if (output === value) {
      console.log(` ${RIGHT} ${input} = ${value}`)
    } else {
      console.log(` ${WRONG} expected ${value}, given ${output}`)
    }
  })

  const output = method(mainInput)
  let consoleOutput = `\nanswer: ${output} `

  if (typeof answer === 'undefined') {
    consoleOutput += NOT_CHECKED
  } else {
    consoleOutput += output === answer ? RIGHT : WRONG
  }

  console.log(consoleOutput)
  console.log()
}
